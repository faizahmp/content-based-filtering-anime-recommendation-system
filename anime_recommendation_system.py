# -*- coding: utf-8 -*-
"""Anime Recommendation System.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SpiJ6vGCRmNUv-2h8AnMZtwzE1CAKyX7

<p align="center"><strong>Content-Based Filtering</strong></p>

# Data Loading

**Detail Atribut:**

**Anime.csv**

- anime_id - id unik anime dari myanimelist.net's
- name - judul anime
- genre - genre dari anime, dipisahkan dengan koma.
- type - tipe anime berupa movie (film), TV, OVA (original animation video), ONA (Original Net Animations), Music (musik), dan Special (spesial).
- episodes - berapa banyak episode (1 jika movie).
- rating - rata-rata nilai rating anime dari 10.
- members - jumlah member dari komunitas anime tersebut.

**Rating.csv**

- user_id - id pengguna yang dihasilkan secara acak dan tidak dapat diidentifikasi.
- anime_id - id anime yang sudah dirating user.
- rating - rating yang diberikan user dari 10 (bernilai -1 jika user sudah menonton anime tetapi tidak memberikan rating).

Sebelum import dataset melalui Kaggle, pastikan sudah mendownload kaggle.json (berupa Kaggle API token).
- Buat sebuah direktori bernama .kaggle
- Copy kaggle.json ke direktori
- Lakukan permission terhadap file
- download dataset
- jika dataset berupa file zip maka unzip terlebih dahulu
"""

! mkdir ~/.kaggle
! cp kaggle.json ~/.kaggle/
! chmod 600 ~/.kaggle/kaggle.json

! kaggle datasets download CooperUnion/anime-recommendations-database

! unzip anime-recommendations-database.zip

"""Import libraries yang dibutuhkan"""

import pandas as pd
import numpy as np
from wordcloud import WordCloud
import matplotlib.pyplot as plt
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""Read data `anime.csv` dan `rating.csv`"""

df_anime = pd.read_csv('/content/anime.csv')
df_rating = pd.read_csv('/content/rating.csv')

df_anime

df_rating

"""Ukuran df_anime sebesar (12294, 7) dan df_rating sebesar (7813737, 3)"""

print(df_anime.shape)
print(df_rating.shape)

"""# Univariate EDA

## df_anime

Periksa informasi mengenai feature-feature yang ada di df_anime.
"""

df_anime.info()

df_anime['name']

"""Jumlah setiap genre di anime"""

df_anime['genre'].value_counts()

#karena setiap kategori dipisahkan dengan koma, maka split kemudian count genrenya
test = df_anime['genre'].str.split(', ')
count = test.explode().value_counts()

genres_cloud = WordCloud(width=800, height=400, background_color='white').generate_from_frequencies(count)
plt.imshow(genres_cloud, interpolation='bilinear')
plt.axis('off')

"""Jumlah setiap tipe di anime"""

df_anime['type'].value_counts()

"""Tidak ada duplikasi untuk id anime"""

df_anime['anime_id'].duplicated().sum()

"""Terdapat duplikasi pada nama anime, hanya saja setelah diperiksa nama dan id anime berbeda, sehingga tidak dilakukan drop."""

duplikat = df_anime[df_anime['name'].duplicated()]
duplikat

"""## df_rating

Untuk periksa informasi yang ada di df_rating.
"""

df_rating.info()

print("Jumlah ID anime di df_anime: ",df_anime['anime_id'].nunique())
print("Jumlah ID anime di df_rating: ",df_rating['anime_id'].nunique())
print("Jumlah ID user: ",df_rating['user_id'].nunique())
print("Jumlah nama anime: ",df_anime['name'].nunique())

"""Sebagai contoh user_id = 2 telah menonton ketiga anime dengan id 11771, 12189, dan 16417. User ini telah menilai anime 11771 dengan nilai 10/10. Sedangkan user ini belum rate kedua anime lainnya yang ditonton, maka nilainya -1."""

df_rating[df_rating['user_id'] == 2]

"""# Data Pre-Processing

Rename jadi `rating_user` pada df_rating agar tidak memiliki nama kolom yang sama saat merge dengan df_anime.
"""

df_rating = df_rating.rename(columns={"rating":"rating_user"})

"""Menggabungkan df_anime dengan df_rating dan memasukkannya ke dalam variabel all_anime_df.

"""

all_anime_df = pd.merge(df_anime, df_rating, on='anime_id', how='left')
all_anime_df

"""Setelah digabungkan, jumlahnya menjadi (7814824, 9)"""

all_anime_df.shape

"""# Data Preparation

Untuk periksa informasi gabungan hasil kedua dataframe.
"""

all_anime_df.info()

"""Untuk user yang tidak rating atau -1 diberikan nilai NaN, karena hal ini sama saja dengan user yang tidak memberikan nilai rating sama sekali atau bernilai 0.

Kemudian rating_user yang bernilai NaN akan didrop.
"""

all_anime_df["rating_user"].replace({-1.0: np.nan}, inplace=True)
all_anime_df.head()

all_anime_df[all_anime_df['rating_user']== -1]

"""Periksa kembali apakah terdapat nilai kosong yang lain."""

all_anime_df.isnull().sum()

"""Drop semua nilai yang bernilai null"""

all_anime_df.dropna(axis=0, how='any', inplace=True)
all_anime_df.isnull().sum()

"""Drop kolom yang duplikasi terutama pada anime_id dan name. Drop tersebut dilakukan untuk melakukan sistem rekomendasi pada nama anime dengan genrenya, sehingga tidak boleh duplikat."""

all_anime_df = all_anime_df.drop_duplicates(subset=['anime_id', 'name'], keep='first')

all_anime_df.head()

"""Agar mudah dibaca dan dipahami oleh mesin, feature name dan genre akan dilakukan cleaning jika memiliki nilai &quot, .hack//, &#039;, A&#039;s, I&#039;, dan &amp; menggunakan library regex."""

def text_cleaning(text):
    text = re.sub(r'&quot;', '', text)
    text = re.sub(r'.hack//', '', text)
    text = re.sub(r'&#039;', '', text)
    text = re.sub(r'A&#039;s', '', text)
    text = re.sub(r'I&#039;', 'I\'', text)
    text = re.sub(r'&amp;', 'and', text)

    return text

all_anime_df['name'] = all_anime_df['name'].apply(text_cleaning)
all_anime_df['genre'] = all_anime_df['genre'].apply(text_cleaning)

"""Ukuran dataframe berubah menjadi (9892, 9) setelah drop kolom yang duplikat



"""

all_anime_df.shape

"""# Modelling

## TF-IDF

Sebelum masuk ke tahap modelling, data akan dilakukan TF-IDF terlebih dahulu untuk menemukan representasi fitur penting dari setiap genre anime.
"""

tf = TfidfVectorizer()

tf.fit(all_anime_df['genre'])

tf.get_feature_names_out()

"""Lakukan fit dan transformasi ke dalam bentuk matriks. Hasilnya berupa 9892 nama anime dengan 47 genre."""

tfidf_matrix = tf.fit_transform(all_anime_df['genre'])

tfidf_matrix.shape

"""Untuk menghasilkan vektor TF-IDF dalam bentuk matriks, gunakan fungsi `todense()`"""

tfidf_matrix.todense()

"""Dataframe dibawah dibuat untuk melihat matriks tf-idf untuk beberapa anime dan genrenya."""

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=all_anime_df.name
).sample(22, axis=1).sample(10, axis=0)

"""## Cosine-Similarity

Sekarang, hitung similarity degree antar anime dengan teknik Cosine-Similarity.
"""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Teknik ini digunakan untuk identifikasi kesamaan antara satu anime dengan anime lainnya."""

cosine_sim_df = pd.DataFrame(cosine_sim, index=all_anime_df['name'], columns=all_anime_df['name'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Buatlah sebuah fungsi `anime_recommendations` dengan parameter:
- anime_name: nama anime
- similarity_data: fungsi cosine-similarity
- items: name dan genre

Keluaran sistem rekomendasi berupa top-N recommendation.


Beberapa penjelasan method dan variable yang digunakan:
- argpartition: mengambil sejumlah nilai k tertinggi dari similarity function
- kemudian, ambil data dari bobot tertinggi ke rendah dan masukkan data ini ke variable closest
- dalam hal ini kita ingin cari rekomendasi dari anime berjudul Persona 5 the Animation: The Day Breakers, sehingga drop anime dengan judul ini agar tidak muncul dalam daftar rekomendasi (tidak double)
"""

def anime_recommendations(anime_name, similarity_data=cosine_sim_df, items=all_anime_df[['name', 'genre']], k=5):
    index = similarity_data.loc[:,anime_name].to_numpy().argpartition(
        range(-1, -k, -1))
    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(anime_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

all_anime_df[all_anime_df['name'].eq('Tentai Senshi Sunred')]

anime_recommendations('Tentai Senshi Sunred')

"""# Model Evaluation

(Perhitungan manual)

Metrik yang digunakan pada model ini adalah Precision score. Precision score pada sistem rekomendasi memiliki rumus n rekomendasi yang relevan / n item yang direkomendasikan. Detailnya sebagai berikut:

![Precision](https://latex.codecogs.com/svg.latex?%5Cdpi%7B300%7D%20%5Csmall%20%5Cbg_white%20%5Cfn_cm%20P%20%3D%20%5Cfrac%7B%5Ctext%7Bour%20recommendations%20that%20are%20relevant%7D%7D%7B%5Ctext%7Bitems%20we%20recommended%7D%7D)

Sebagai contoh `anime_recommendations('Tentai Senshi Sunred')` memberikan rekomendasi seperti di atas.

Genre pada anime Tentai Senshi Sunred adalah Comedy, Parody, Seinen, Super Power. Maka dari 5 item yang direkomendasikan, anime dari nomor 0-3 memiliki kategori yang persis sama dengan anime Tentai. Artinya nilai Precision sebesar:

P = 4/5 = 0.8 = 80%

Jadi, nilai precision score pada anime Tentai Senshi Sunred adalah **80%**.

---
"""